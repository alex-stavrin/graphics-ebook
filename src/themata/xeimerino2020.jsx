import { InlineMath } from "react-katex";
import {Prism as SyntaxHighlighter} from "react-syntax-highlighter";
import { oneDark } from "react-syntax-highlighter/dist/esm/styles/prism";
import MatrixMath from "../components/Matrix";

export default function Xeimerino2020()
{

    
    return <div className="flex flex-col gap-3">
        <h1>Θέματα Χειμερινό 2020</h1>
        <a target="_blank" href="https://drive.google.com/drive/folders/17tOUKBmdix7qKG0NEoZkkYFRlz4HFviW?usp=sharing">Θέματα</a>
        <h2>Θέμα 1. Σχεδίαση</h2>
        <h3>1Α</h3>
        <p>Στα παρακάτω θεματα όπου υπάρχει "/", επιλέξτε το σωστό. Όπου ___ συμπληρώστε την λέξη</p>
        <p>Ενα κυρτο 2D σχήμα με n ακμες μπορει να σχεδιασθει με τον υπολογισμο των ___ γραμμικων/τετραγωνικων συναρτησεων
            , σε καθε εικονοστοιχειο/ογκοστοιχειο/κορυφη του περιβαλλοντος παραλληλογραμου του. Αν το μεγεθος/προσημο
            των τιμων που προκυπτουν ειναι το ιδιο/διαφορετικο, τοτε το αντιστοιχο εικονοστοιχειο/ογκοστοιχειο/κορυφη βρίσκεται εντος του κυρτου σχηματος
        </p>
        <p>Το σωστό είναι</p>
        <p>Ενα κυρτο 2D σχήμα με n ακμες μπορει να σχεδιασθει με τον υπολογισμο των <span className="text-green-600">τιμών γραμμικων</span> συναρτησεων
            , σε καθε <span className="text-green-600">εικονοστοιχειο</span> του περιβαλλοντος παραλληλογραμου του. Αν το <span className="text-green-600">προσημο </span> 
            των τιμων που προκυπτουν ειναι το <span className="text-green-600">ιδιο</span>, τοτε το αντιστοιχο <span className="text-green-600">εικονοστοιχειο</span>  βρίσκεται εντος του κυρτου σχηματος
        </p>
        <h3>1Β</h3>
        <p>Ο παρακάτω αλγόριθμος περιγράφει έναν τετοιο αλγόριθμο για κυρτά τετράπλευρα. Βρείτε 3 λογικά λάθη</p>
        <SyntaxHighlighter style={oneDark} language={"cpp"} showLineNumbers>
            {
`quad(vertex v0, vertex v1, vertex v2, vertex v3, colour c)
{
   // we assume each line has coefficients a,b,c
   line l0,l1,l2,l3;

   // bounding box
   float bb_xmin, bb_xmax, bb_ymin, bb_ymax;
   float e0, e1, e2, e3, e0t, e1t, e2t, e3t;

   e0 = l0.a * bb_xmin + l0.b * bb_ymin + l0.c;
   e1 = l1.a * bb_xmin + l1.b * bb_ymin + l1.c;
   e2 = l2.a * bb_xmin + l2.b * bb_ymin + l2.c;
   e3 = l3.a * bb_xmin + l3.b * bb_ymin + l3.c;

   for(y=bb_ymin; y<=bb_ymax;y++)
   {
       e0t = e0;
       e1t = e1;
       e2t = e2;
       e3t = e3;
       for(x=bb_xmin; x<=bb_xmax; x++)
       {
           if not((sign(e0) == sign(e1)) && (sign(e0) == sign(e1)) && (sign(e0) == sign(e3)))
           {
               setpixel(x,y,c);
               e1 = e1 + l1.a;
               e2 = e2 + l2.a;
               e3 = e3 + l3.a;
           }
       }
       e1 = e1t + l1.b;
       e2 = e2t + l2.b;
       e2 = e3t + l3.b;
   }
}`}
        </SyntaxHighlighter>

        <p>Στον παραπάνω αλγόριθμο υπάρχουν τα εξής 3 λογικά λάθη</p>
        <ul className="list-disc ml-5">
            <li>
                Στην γραμμή 23 δεν χρειάζεται το not
            </li>
            <li>
                Οι γραμμές 26-28 ξεχνάν το e0. Επίσης πρέπει να είναι έξω απο το if
            </li>
            <li>
                Οι γραμμές 31-33 ξεχνάν πάλι το e1
            </li>
        </ul>
        <p>Άρα η τελική μορφή του σωστού κώδικα είναι :</p>
                <SyntaxHighlighter style={oneDark} language={"cpp"} showLineNumbers>
            {
`quad(vertex v0, vertex v1, vertex v2, vertex v3, colour c)
{
   // we assume each line has coefficients a,b,c
   line l0,l1,l2,l3;

   // bounding box
   float bb_xmin, bb_xmax, bb_ymin, bb_ymax;
   float e0, e1, e2, e3, e0t, e1t, e2t, e3t;

   e0 = l0.a * bb_xmin + l0.b * bb_ymin + l0.c;
   e1 = l1.a * bb_xmin + l1.b * bb_ymin + l1.c;
   e2 = l2.a * bb_xmin + l2.b * bb_ymin + l2.c;
   e3 = l3.a * bb_xmin + l3.b * bb_ymin + l3.c;

   for(y=bb_ymin; y<=bb_ymax;y++)
   {
       e0t = e0;
       e1t = e1;
       e2t = e2;
       e3t = e3;
       for(x=bb_xmin; x<=bb_xmax; x++)
       {
           if not((sign(e0) == sign(e1)) && (sign(e0) == sign(e1)) && (sign(e0) == sign(e3)))
           {
               setpixel(x,y,c);
           }
           e0 = e0 + l0.a;
           e1 = e1 + l1.a;
           e2 = e2 + l2.a;
           e3 = e3 + l3.a;
       }
       e0 = e0t + l0.b;
       e1 = e1t + l1.b;
       e2 = e2t + l2.b;
       e2 = e3t + l3.b;
   }
}`}
        </SyntaxHighlighter>
        <h3>1Γ</h3>
        <p>Ο παραπάνω αλγόριθμος υπολογίζει τις συναρτήσεις ακμών αυξητικά με χρήση πεπερασμένων διαφορών. Αν οι υπολογισμοί έπρεπει να γίνουν παράλληα έτσι ώστε η μονάδα επεξεργασίας (i,j) να είναι υπεύθυνη για το 2D σημείο (i,j), πιστεύτε οτι θα δημιουργηθεί πρόβλημα σχετικά με τους αυξητικούς υπολογισμούς?</p>
        <p>Ναι με αυξητικούς υπολογισμούς δημιοργείται πρόβλημα, καθώς οι υπολογισμοί βασίζονται σε προηγούμενες τιμές. Οποτε δεν είναι κάτι που μπρορούμε να παραλληλοποιήσουμε</p>
        <h2>Θέμα 2. Μετασχηματισμοί</h2>
        <h3>2Α</h3>
        <p>Στα παρακάτω θεματα όπου υπάρχει "/", επιλέξτε το σωστό. Όπου ___ συμπληρώστε την λέξη</p>
        <p>Στα Γραφικά χρησιμοποιούμε 4 βασικούς συσχετισμένους μετασχηματισμούς, οι οποιο συνδυαζόμενοι μπορούν να δώσουν οποιονδήποτε άλλον. Η σειρα συνδυασμού είναι
            σημαντική καθώς, γενικά, ο πολλαπλιασμός πινάκων δεν εχει την προσεταιριστική/αντιμεταθετική ιδιότητα. Λόγο υπολογιστικής αποτελεσματικότητας,
            είναι προτιμητέο να συνδυάσουμε τους βασικούς πίνακες πρίν/μετά την εφαρμογή τους στις κορυφές και σε αυτό βοηθά η προσεταιριστική/αντιμεταθετική ιδιότητα του πολλαπλασιασμού πινάκων. Ο λόγος
            που ο συνδυασμός των πινάκων με αυτό τον τρόπο βοηθά στην υπολογιστική αποτελεσματικότητα, είναι ότι γενικά έχουμε λίγους/πολλούς πίνακες μετασχηματισμού και λίγες/πολλές κορυφές
            πανω στις οποίες εφαρμόζονται
        </p>
        <p>Το κείμενο με σωστές απαντήσεις είναι:</p>
        <p>Στα Γραφικά χρησιμοποιούμε 4 βασικούς συσχετισμένους μετασχηματισμούς, οι οποιο συνδυαζόμενοι μπορούν να δώσουν οποιονδήποτε άλλον. Η σειρα συνδυασμού είναι
            σημαντική καθώς, γενικά, ο πολλαπλιασμός πινάκων δεν εχει την <span className="text-green-600">αντιμεταθετική</span> ιδιότητα. Λόγο υπολογιστικής αποτελεσματικότητας,
            είναι προτιμητέο να συνδυάσουμε τους βασικούς πίνακες <span className="text-green-600">πριν</span> την εφαρμογή τους στις κορυφές και σε αυτό βοηθά η <span className="text-green-600">προσεταιριστική</span> ιδιότητα του πολλαπλασιασμού πινάκων. Ο λόγος
            που ο συνδυασμός των πινάκων με αυτό τον τρόπο βοηθά στην υπολογιστική αποτελεσματικότητα, είναι ότι γενικά έχουμε <span className="text-green-600">λίγους</span> πίνακες μετασχηματισμού και <span className="text-green-600">πολλές</span> κορυφές
            πανω στις οποίες εφαρμόζονται
        </p>
        <h3>2B</h3>
        <p>Υπολογίστε τους μετασχηματισμούς που απαιτούνται για την μετατροπή του αντικειμένου K:</p>
        <p>
            <InlineMath math="K=[V1,V2,V3,V4]="/>
            <MatrixMath matrix={[
                [1,0,0,0],
                [0,2,0,0],
                [0,0,3,0],
                [1,1,1,1]
            ]}/>
        </p>
        <p>Σε καθένα απο τα παρακάτω αντικείμενα</p>
        <p>
            <InlineMath math="K_1="/>
            <MatrixMath matrix={[
                [4,3,3,3],
                [2,4,2,2],
                [1,1,4,1],
                [1,1,1,1]
            ]}/>
        </p>
        <p>Για την μετατροπή απο <InlineMath math="K"/> σε <InlineMath math="K_1"/> θα πολλαπλασιάσουμε με τον πίνακα <InlineMath math="T(3,2,1)"/></p>
        <p>
            <InlineMath math="T(3,2,1)="/>
            <MatrixMath matrix={[
                [1,0,0,3],
                [0,1,0,2],
                [0,0,1,1],
                [0,0,0,1]
            ]}/>
        </p>
        <p>
            <InlineMath math="T(3,2,1)\cdot K = "/>
            <MatrixMath matrix={[
                [1,0,0,3],
                [0,1,0,2],
                [0,0,1,1],
                [0,0,0,1]
            ]}/>
            <MatrixMath matrix={[
                [1,0,0,0],
                [0,2,0,0],
                [0,0,3,0],
                [1,1,1,1]
            ]}/>
            <InlineMath math="=K_1"/>  
        </p>
        <p>
            <InlineMath math="K_2="/>
            <MatrixMath matrix={[
                [4,3,3,3],
                [1,2,1,1],
                [2,2,8,2],
                [1,1,1,1]
            ]}/>
        </p>
        <p>Για μετατροπή απο <InlineMath math="K"/> σε <InlineMath math="K_2"/> αρχικά θα πολλαπλασιάσουμε κατα <InlineMath math="S(1,\frac{1}{2},2)"/></p>
        <p>
            <InlineMath math="S(1,\frac{1}{2},2)="/>
            <MatrixMath matrix={[
                [1,0,0,0],
                [0,"\\frac{1}{2}",0,0],
                [0,0,2,0],
                [0,0,0,1]
            ]}/>
        </p>
        <p>Μετα θα κάνουμε μια μετατόπιση κατα <InlineMath math="\vec{d}=[3,1,2]"/></p>
        <p>
            <InlineMath math="T(\vec{d})="/>
            <MatrixMath matrix={[
                [1,0,0,3],
                [0,1,0,1],
                [0,0,1,2],
                [0,0,0,1]
            ]}/>
        </p>
        <p>Αρα</p>
        <p>
            <InlineMath math="T(\vec{d}) \cdot S(1,\frac{1}{2},3)\cdot K="/>
            <MatrixMath matrix={[
                [1,0,0,3],
                [0,"\\frac{1}{2}",0,1],
                [0,0,2,2],
                [0,0,0,1]
            ]}/>
            <InlineMath math="\cdot K="/>
            <MatrixMath matrix={[
                [4,3,3,3],
                [1,2,1,1],
                [2,2,8,2],
                [1,1,1,1]
            ]}/>
            <InlineMath math="=K_2"/>
        </p>
        <h2>Θέμα 3. Χρώμα και Φωτισμός</h2>
        <h3>3A</h3>
        <p>
            Εστω οτι έχετε 2 bits άνα εικονοστοιχείο για την αποθήκευση έντασης (αποχρώσεις του γκρι). Ποια θα ηταν τα 4 επίπεδα έντασης που θα επιλέγατε
            να παραστήσετε, μεταξύ της ελάχιστης έντασης (0.1) και τηνς μέγιστης έντασης (1.0), έτσι ώστε να μεγιστοποιήσετε την χρησιμότητα για το ανθρώπινο μάτι
        </p>
        <ul className="list-disc ml-5">
            <li>
                0.1 , 0.4 , 0.7 , 1.0
            </li>
            <li>
                0.1 , 0.2 , 0.4 , 0.8
            </li>
            <li>
                0.1 , 0.21 , 0.46 , 1.0
            </li>
            <li>
                0.1 , 0.2 , 0.4 , 1.0
            </li>
        </ul>
        <p>Θα κάνουμε μια γεωμετρική προόδο απο το <InlineMath math="I_{min}=0.1"/> έως το <InlineMath math="I_{max}=1"/> με <InlineMath math="n=4"/> βήματα</p>
        <p><InlineMath math="r=(\frac{I_{max}}{I_{min}})^{\frac{1}{n-1}}=(\frac{1}{0.1})^{\frac{1}{3}}=10^{\frac{1}{3}} \approx 2.15"/></p>
        <p><InlineMath math="I_0=0.1 \cdot r^0=0.1"/></p>
        <p><InlineMath math="I_1=0.1 \cdot r^1=0.1 \cdot 2.15 \approx 0.215"/></p>
        <p><InlineMath math="I_2=0.1 \cdot r^2= 0.1 \cdot 4.6225 \approx 0.46225"/></p>
        <p><InlineMath math="I_3=0.1 \cdot r^3=0.1 \cdot 0.993 \approx 1"/></p>
        <p>Άρα οι τιμές που διαλέγουμε είναι:</p>
        <p>0.1 , 0.21 , 0.46 , 1.0</p>
        <h3>3Β</h3>
        <p>Εξηγήστε το σκεπτικό της επιλογής σας στο προηγούμενο υποερώτημα 3Α</p>
        <p>Η παραπανω υπολογισμοί έγιναν καθώς το ανθρώπινο μάτι αντιλαμβάνεται την ένταση λογαριθμικά και όχι γραμμικά</p>
        <h3>3Γ</h3>
        <p>Πως εκμεταλλεύονται την θεωρία που αναπτύξατε στο υποερώτημα 3Β οι εικόνες υψηλού δυναμικού εύρους (HDR)? Διαλέξτε ένα</p>
        <ul className="list-disc ml-5">
            <li>
                Χρησιμοποιούν μη γραμμική παρεμβολή για τον υπολογισμό τιμών έντασης μεταξύ HDR τιμών που έχουν καταγραφεί με εξειδικευμένο εξοπλισμό
            </li>
            <li className="text-green-600">
                Το φορμά αρχείων HDR εξοικονομούν bits αναθέτοντας τιμές έντασης με λογαριθμική κατανομή
            </li>
            <li>
                Δεν χρησιμοποιούν την παραπάνω θεωρία
            </li>
            <li>
                Το φορμά αρχείων HDR πάνα αναθέτους τιμές έντασης έμμεσα (πχ όπως  στο RGB)
            </li>
        </ul>
        <h3>3Δ</h3>
        <p>Δείξτε πώς η εξίσωση του μοντέλου Phong μπορεί να προεκταθεί ώστε να λαμβάνει υπόψη του πολλαπλές φωτεινές πηγές καθώς και την απόσταση της κάθε φωτεινής πηγής απο το φωτιζόμενο σημείο. Δικαιολογήστε τις μεταβλητές που εξαρτώνται απο την κάθε φωτεινή πηγή</p>
        <p><InlineMath math="I=I_e+I_ak_a+\sum_j[f(d_j)I_{j}(k_dmax(0,\hat{n}\cdot\hat{I}_j)+k_smax(0,(\hat{n}\cdot\hat{r}_j)^n))]"/></p>
        <ul className="ml-5 list-disc">
            <li>
                <InlineMath math="I_j="/> ένταση πηγής
            </li>
            <li>
                <InlineMath math="\hat{I}_j="/> διάνυσμα απο τη πηγή στο σημείο
            </li>
            <li>
                <InlineMath math="\hat{r}_j="/> διάνυσμα ανάκλασης για την πηγή
            </li>
            <li>
                <InlineMath math="d_j="/> απόσταση πηγής απο το σημείο 
            </li>
            <li>
                <InlineMath math="f(d_j)="/> συνάρτηση εξασθένισης απόστασης
            </li>
        </ul>
    </div>
}